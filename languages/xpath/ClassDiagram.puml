@startuml
namespace xpath {
    interface ExecutorCommand  {
        + Execute(xpathQuery string) ExecutorCommand
        + AgainstFile(documentFilePath string) ExecutorCommand
        + AgainstString(input []byte) ExecutorCommand
        + WithNumberOfThreads(numberOfThreads int) ExecutorCommand
        + Go() ([]Position, error)
        + InVerboseMode() ExecutorCommand

    }
    interface Logger  {
        + Printf( string,  ...<font color=blue>interface</font>{}) 

    }
    interface Position  {
        + Extremes() int
        + Start() int
        + End() int

    }
    class andOperatorImpl << (S,Aquamarine) >> {
        - previousOperand customBool

        - evaluate(operand customBool) customBool

    }
    class atomOperatorImpl << (S,Aquamarine) >> {
        - evaluate(operand customBool) customBool

    }
    class attribute << (S,Aquamarine) >> {
        - key string

        + String() string

    }
    class axis << (S,Aquamarine) >> {
        + String() string

    }
    class closeTagSemanticValue << (S,Aquamarine) >> {
        - id string
        - posInDocument *position

    }
    interface contextSolutionsMap  {
        - addContextSolution(ctx nonTerminal, sols ...nonTerminal) 
        - transitiveClosure(maps ...contextSolutionsMap) contextSolutionsMap
        - hasSolutionsFor(ctx nonTerminal) bool
        - solutionsFor(ctx nonTerminal, maps ...contextSolutionsMap) []nonTerminal
        - merge(incoming contextSolutionsMap) (contextSolutionsMap, bool)
        - convertToGroupOfSolutionsPositions() []Position

    }
    class contextSolutionsMapImpl << (S,Aquamarine) >> {
        - m implementedMapType

        - addContextSolution(ctx nonTerminal, sols ...nonTerminal) 
        - hasSolutionsFor(ctx nonTerminal) bool
        - solutionsFor(ctx nonTerminal, maps ...contextSolutionsMap) []nonTerminal
        - transitiveClosure(maps ...contextSolutionsMap) contextSolutionsMap
        - convertToGroupOfSolutionsPositions() []Position
        - merge(incoming contextSolutionsMap) (contextSolutionsMap, bool)

    }
    class customBool << (S,Aquamarine) >> {
        - tobool() bool

        + String() string

    }
    class element << (S,Aquamarine) >> {
        - name string
        - attributes []*attribute
        - posInDocument *position

        - position() *position
        - setFromExtremeTags(openTag openTagSemanticValue, closeTag closeTagSemanticValue) 
        - setFromSingleTag(openCloseTag openCloseTagSemanticValue) 

        + String() string

    }
    class elementTest << (S,Aquamarine) >> {
        - wildCard bool
        - name string
        - attr *attribute
        - pred predicate

        - predicate() predicate
        - test(tested <font color=blue>interface</font>{}) bool

        + String() string

    }
    interface executionRecord  {
        - addExecutionThread(ctx nonTerminal, sol nonTerminal, pp pathPattern) executionThread
        - removeExecutionThread(et executionThread, removeChildren bool) bool
        - hasExecutionThreadRunningFor(ctx nonTerminal) bool
        - hasSolutionsFor(ctx nonTerminal) bool
        - contextSolutions() contextSolutionsMap
        - merge(incoming executionRecord) (executionRecord, bool)
        - updateAllExecutionThreads(reduced nonTerminal) 
        - stopUnfoundedSpeculativeExecutionThreads(evaluator evaluator) 
        - saveReducedNTAsContextOrSolutionlIntoCompletedExecutionThreads( nonTerminal) 
        - produceContextSolutionsOutOfCompletedNonSpeculativeExecutionThreads() 
        - udpeType() udpeType
        - nudpeRecord() globalNudpeRecord
        - belongsToNudpe() bool

    }
    class executionRecordImpl << (S,Aquamarine) >> {
        - expType udpeType
        - t executionTable
        - ctxSols contextSolutionsMap
        - etList executionThreadList
        - gNudpeRecord globalNudpeRecord

        - addExecutionThread(ctx nonTerminal, sol nonTerminal, pp pathPattern) executionThread
        - removeExecutionThread(et executionThread, removeChildren bool) bool
        - hasExecutionThreadRunningFor(ctx nonTerminal) bool
        - hasSolutionsFor(ctx nonTerminal) bool
        - contextSolutions() contextSolutionsMap
        - udpeType() udpeType
        - nudpeRecord() globalNudpeRecord
        - belongsToNudpe() bool
        - updateAllExecutionThreads(reduced nonTerminal) 
        - stopUnfoundedSpeculativeExecutionThreads(evaluator evaluator) 
        - saveReducedNTAsContextOrSolutionlIntoCompletedExecutionThreads(contextOrSolution nonTerminal) 
        - produceContextSolutionsOutOfCompletedNonSpeculativeExecutionThreads() 
        - merge(incoming executionRecord) (executionRecord, bool)

        + String() string

    }
    interface executionTable  {
        - merge(incoming executionTable) (executionTable, bool)
        - iterate(callback executionTableIterableCallback) 
        - recordByID(id int) (executionRecord, error)
        - mainQueryRecord() executionRecord
        - evaluateID(udpeID int, context nonTerminal, evaluationsCount int) customBool
        - size() int

    }
    class executionTableImpl << (S,Aquamarine) >> {
        - list []executionRecord

        - iterate(callback executionTableIterableCallback) 
        - recordByID(id int) (executionRecord, error)
        - mainQueryRecord() executionRecord
        - merge(incoming executionTable) (executionTable, bool)
        - size() int
        - evaluateID(udpeID int, context nonTerminal, evaluationsCount int) customBool

    }
    interface executionThread  {
        - context() nonTerminal
        - solution() nonTerminal
        - setNTAsContextOrSolutionIfNotAlreadySet( nonTerminal) 
        - pathPattern() pathPattern
        - isCompleted() bool
        - isSpeculative() bool
        - addSpeculation(pr predicate, ctx nonTerminal) speculation
        - removeSpeculation(sp speculation) 
        - addChild(et executionThread) 
        - children() []executionThread
        - checkAndUpdateSpeculations(v evaluator) bool

    }
    class executionThreadImpl << (S,Aquamarine) >> {
        - ctx nonTerminal
        - sol nonTerminal
        - pp pathPattern
        - spList speculationList
        - offspr []executionThread
        - el *list.Element

        - setNTAsContextOrSolutionIfNotAlreadySet(contextOrSolution nonTerminal) 
        - context() nonTerminal
        - solution() nonTerminal
        - pathPattern() pathPattern
        - isCompleted() bool
        - isSpeculative() bool
        - addSpeculation(prd predicate, ctx nonTerminal) speculation
        - removeSpeculation(sp speculation) 
        - addChild(child executionThread) 
        - children() []executionThread
        - checkAndUpdateSpeculations(v evaluator) bool

        + String() string

    }
    interface executionThreadList  {
        - addExecutionThread(ctx nonTerminal, sol nonTerminal, pp pathPattern) executionThread
        - removeExecutionThread(et executionThread, removeChildren bool) bool
        - hasExecutionThreadRunningFor(ctx nonTerminal) bool
        - iterate(callback executionThreadListIterableCallback) 
        - newIterator() executionThreadListIterator
        - len() int
        - merge(incoming executionThreadList) (executionThreadList, bool)

    }
    class executionThreadListImpl << (S,Aquamarine) >> {
        - list *list.List

        - addExecutionThread(ctx nonTerminal, sol nonTerminal, pp pathPattern) executionThread
        - removeExecutionThread(et executionThread, removeChildren bool) bool
        - hasExecutionThreadRunningFor(ctx nonTerminal) bool
        - len() int
        - merge(incoming executionThreadList) (executionThreadList, bool)
        - newIterator() executionThreadListIterator
        - iterate(callback executionThreadListIterableCallback) 

    }
    interface executionThreadListIterator  {
        - hasNext() bool
        - next() (executionThread, bool)

    }
    class executionThreadListIteratorImpl << (S,Aquamarine) >> {
        - nextEl *list.Element

        - hasNext() bool
        - next() (executionThread, bool)

    }
    interface executor  {
        - setXPathQueryToBeExecuted(xpathquery string) 
        - setNumberOfThreadsToBeUsedToParseDocument(numberOfThreads int) 
        - setDocumentToBeParsedFilePath(documentFilePath string) 
        - initSingletonDataStructures() 
        - freeSingletonDataStructures() 
        - parseXPathQueryAndPopulateSingletonsDataStructures() error
        - executeUDPEsWhileParsingDocumentFile() error
        - completeExecutionOfUDPEsAndNUDPEs() error
        - retrieveResults() []Position

    }
    class executorCommandImpl << (S,Aquamarine) >> {
        - xpathQuery string
        - inputString []byte
        - documentFilePath string
        - numberOfThreads int
        - verbose bool

        + Execute(xpathQuery string) ExecutorCommand
        + AgainstFile(filePath string) ExecutorCommand
        + AgainstString(input []byte) ExecutorCommand
        + WithNumberOfThreads(numberOfThreads int) ExecutorCommand
        + InVerboseMode() ExecutorCommand
        + Go() ([]Position, error)

    }
    class executorImpl << (S,Aquamarine) >> {
        - numberOfThreads int
        - xpathQueryToBeExecuted string
        - mainQueryType mainQueryType
        - documentFilePath string
        - input []byte
        - resultingExecutionTable executionTable

        - initSingletonDataStructures() 
        - freeSingletonDataStructures() 
        - setXPathQueryToBeExecuted(xpathQuery string) 
        - setNumberOfThreadsToBeUsedToParseDocument(numberOfThreads int) 
        - setDocumentToBeParsedFilePath(documentFilePath string) 
        - parseXPathQueryAndPopulateSingletonsDataStructures() error
        - executeUDPEsWhileParsingDocumentFile() error
        - completeExecutionOfUDPEsAndNUDPEs() error
        - nudpeBooleanValueEvaluator(udpeID int, context nonTerminal, evaluationsCount int) customBool
        - retrieveResults() []Position

        + A1() 
        + A2() 
        + A3() 
        + A4() 
        + A5() 
        + A6() 
        + A7() 
        + A8() 
        + B1() 
        + B2() 

    }
    interface fpe  {
    }
    interface fpeBuilder  {
    }
    class fpeBuilderImpl << (S,Aquamarine) >> {
        - state fpeBuilderState
        - precedentFpeInnerTest *fpeInnerTestImpl

        - init() 
        - addUdpeTest(udpeTest udpeTest) bool
        - addAxis(axis axis) bool
        - end() udpe

    }
    class fpeImpl << (S,Aquamarine) >> {
        - entryTest *fpeInnerTestImpl

        - entryPoint() pathPattern

        + String() string

    }
    class fpeInnerTestImpl << (S,Aquamarine) >> {
        - isEntry bool
        - behindDescendantAxis bool
        - udpeTest udpeTest
        - precedingFpeInnerTest *fpeInnerTestImpl

        - matchWithReductionOf(n <font color=blue>interface</font>{}) (predicate, *fpeInnerTestImpl, bool)
        - entry() bool

        + String() string

    }
    class fpePathPatternImpl << (S,Aquamarine) >> {
        - currentTest *fpeInnerTestImpl

        - isEmpty() bool
        - matchWithReductionOf(n <font color=blue>interface</font>{}, doUpdate bool) (predicate, pathPattern, bool)

        + String() string

    }
    interface globalNudpeRecord  {
        - length() int
        - hasSolutionsFor(ctx nonTerminal) bool
        - contextSolutions() contextSolutionsMap
        - setContextSolutions( contextSolutionsMap) 

    }
    class globalNudpeRecordImpl << (S,Aquamarine) >> {
        - ctxSols contextSolutionsMap
        - len int

        - contextSolutions() contextSolutionsMap
        - setContextSolutions(ctxSols contextSolutionsMap) 
        - length() int
        - hasSolutionsFor(ctx nonTerminal) bool

    }
    interface globalNudpeTable  {
        - recordByID(id int) globalNudpeRecord
        - mainQueryRecord() globalNudpeRecord
        - addNudpeRecord(length int) globalNudpeRecord
        - size() int
        - newIterator() globalNudpeTableIterator

    }
    class globalNudpeTableImpl << (S,Aquamarine) >> {
        - list []*globalNudpeRecordImpl

        - recordByID(id int) globalNudpeRecord
        - mainQueryRecord() globalNudpeRecord
        - addNudpeRecord(length int) globalNudpeRecord
        - size() int
        - newIterator() globalNudpeTableIterator

    }
    interface globalNudpeTableIterator  {
        - hasNext() bool
        - next() globalNudpeRecord

    }
    class globalNudpeTableIteratorImpl << (S,Aquamarine) >> {
        - table *globalNudpeTableImpl
        - nextRecordID int

        - hasNext() bool
        - next() globalNudpeRecord

    }
    interface globalUdpeRecord  {
        - udpe() udpe
        - udpeType() udpeType
        - nudpeRecord() globalNudpeRecord
        - setNudpeRecord(nudpeRecord globalNudpeRecord) 

    }
    class globalUdpeRecordImpl << (S,Aquamarine) >> {
        - exp udpe
        - expType udpeType
        - gNudpeRecord globalNudpeRecord

        - udpe() udpe
        - udpeType() udpeType
        - nudpeRecord() globalNudpeRecord
        - setNudpeRecord(nudpeRecord globalNudpeRecord) 

    }
    interface globalUdpeTable  {
        - newExecutionTable() executionTable
        - addFpe(fpe fpe) (int, globalUdpeRecord)
        - addRpe(rpe rpe) (int, globalUdpeRecord)
        - iterate(callback globalTableIterableCallback) 
        - mainQueryRecord() globalUdpeRecord

    }
    class globalUdpeTableImpl << (S,Aquamarine) >> {
        - list []globalUdpeRecord

        - newExecutionTable() executionTable
        - size() int
        - recordByID(id int) globalUdpeRecord
        - mainQueryRecord() globalUdpeRecord
        - iterate(callback globalTableIterableCallback) 
        - addFpe(fpe fpe) (int, globalUdpeRecord)
        - addRpe(rpe rpe) (int, globalUdpeRecord)
        - addUdpe(udpe udpe, udpeType udpeType) (int, globalUdpeRecord)

    }
    class int64Pool << (S,Aquamarine) >> {
        - pool []int64
        - cur int

        + Get() *int64
        + Remainder() int

    }
    class iterator << (S,Aquamarine) >> {
        - los *listOfStacks
        - cur *stack
        - pos int

        + Prev() *symbol
        + Cur() *symbol
        + Next() *symbol

    }
    class iteratorPtr << (S,Aquamarine) >> {
        - los *listOfStackPtrs
        - cur *stackPtr
        - pos int

        + Prev() *symbol
        + Cur() *symbol
        + Next() *symbol

    }
    class lexResult << (S,Aquamarine) >> {
        - threadNum int
        - tokenList *listOfStacks
        - success bool

    }
    class lexer << (S,Aquamarine) >> {
        - data []byte
        - startPosInInput int
        - pos int

        - yyLex(thread int, genSym *symbol) int
        - getAbsPosOfSymbol(relStart int, relEnd int) *position

    }
    class lexerDfaState << (S,Aquamarine) >> {
        + Transitions []int
        + IsFinal bool
        + AssociatedRules []int

    }
    class listOfStackPtrs << (S,Aquamarine) >> {
        - head *stackPtr
        - cur *stackPtr
        - len int
        - firstTerminal *symbol
        - pool *stackPtrPool

        - findFirstTerminal() *symbol

        + Push(sym *symbol) *symbol
        + Pop() *symbol
        + Merge(l2 listOfStackPtrs) 
        + Split(numSplits int) []listOfStackPtrs
        + Length() int
        + NumStacks() int
        + FirstTerminal() *symbol
        + UpdateFirstTerminal() 
        + Println() 
        + HeadIterator() iteratorPtr
        + TailIterator() iteratorPtr

    }
    class listOfStacks << (S,Aquamarine) >> {
        - head *stack
        - cur *stack
        - len int
        - pool *stackPool

        + Push(sym *symbol) *symbol
        + Pop() *symbol
        + Merge(l2 listOfStacks) 
        + Split(numSplits int) []listOfStacks
        + Length() int
        + NumStacks() int
        + Println() 
        + HeadIterator() iterator
        + TailIterator() iterator

    }
    interface node  {
        - position() *position

    }
    interface nonTerminal  {
        - setExecutionTable(exexTab executionTable) nonTerminal
        - setNode(n <font color=blue>interface</font>{}) nonTerminal
        - children() []nonTerminal
        - setDirectChildAndInheritItsChildren( nonTerminal) nonTerminal
        - executionTable() executionTable
        - node() <font color=blue>interface</font>{}
        - position() Position

    }
    class nonTerminalImpl << (S,Aquamarine) >> {
        - n <font color=blue>interface</font>{}
        - ch []nonTerminal
        - execTab executionTable

        - setExecutionTable(executionTable executionTable) nonTerminal
        - executionTable() executionTable
        - setNode(n <font color=blue>interface</font>{}) nonTerminal
        - node() <font color=blue>interface</font>{}
        - setDirectChildAndInheritItsChildren(child nonTerminal) nonTerminal
        - children() []nonTerminal
        - position() Position

        + String() string

    }
    class nopLoggerImpl << (S,Aquamarine) >> {
        + Printf(format string, v ...<font color=blue>interface</font>{}) 

    }
    class notOperatorImpl << (S,Aquamarine) >> {
        - evaluate(operand customBool) customBool

    }
    class openCloseTagSemanticValue << (S,Aquamarine) >> {
    }
    class openTagSemanticValue << (S,Aquamarine) >> {
        - id string
        - attributes []*attribute
        - posInDocument *position

    }
    interface operator  {
        - evaluate(operand customBool) customBool

    }
    class orOperatorImpl << (S,Aquamarine) >> {
        - previousOperand customBool

        - evaluate(operand customBool) customBool

    }
    class parseResult << (S,Aquamarine) >> {
        - threadNum int
        - stack *listOfStackPtrs
        - success bool

    }
    class parsingStats << (S,Aquamarine) >> {
        + NumLexThreads int
        + NumParseThreads int
        + StackPoolSizes []int
        + StackPoolNewNonterminalsSizes []int
        + StackPtrPoolSizes []int
        + StackPoolSizeFinalPass int
        + StackPoolNewNonterminalsSizeFinalPass int
        + StackPtrPoolSizeFinalPass int
        + AllocMemTime time.Duration
        + CutPoints []int
        + LexTimes []time.Duration
        + LexTimeTotal time.Duration
        + NumTokens []int
        + NumTokensTotal int
        + ParseTimes []time.Duration
        + RecombiningStacksTime time.Duration
        + ParseTimeFinalPass time.Duration
        + ParseTimeTotal time.Duration
        + RemainingStacks []int
        + RemainingStacksNewNonterminals []int
        + RemainingStackPtrs []int
        + RemainingStacksFinalPass int
        + RemainingStacksNewNonterminalsFinalPass int
        + RemainingStackPtrsFinalPass int

    }
    interface pathPattern  {
        - matchWithReductionOf(n <font color=blue>interface</font>{}, doUpdate bool) (predicate, pathPattern, bool)
        - isEmpty() bool

        + String() string

    }
    class pool << (S,Aquamarine) >> {
        - pool []<font color=blue>interface</font>{}
        - cur int
        - constructor <font color=blue>func</font>() <font color=blue>interface</font>{}

        + Get() <font color=blue>interface</font>{}
        + Remainder() int

    }
    class position << (S,Aquamarine) >> {
        - start int

        + String() string
        + Start() int
        + End() int
        + Extremes() int

    }
    interface predicate  {
        - earlyEvaluate(atomID atomID, value customBool) customBool
        - atomsIDs() []atomID
        - copy() predicate

    }
    class predicateImpl << (S,Aquamarine) >> {
        - value customBool
        - expressionVector []operator
        - atomsLookup <font color=blue>map</font>[atomID]int

        - parentIndexOf(opIndex int) int
        - leftChildIndexOf(opIndex int) int
        - rightChildIndexOf(opIndex int) int
        - atomsIDs() []atomID
        - earlyEvaluate(atomID atomID, value customBool) customBool
        - copy() predicate

        + String() string

    }
    interface reduction  {
        - setup(reducedNT nonTerminal, generativeNT nonTerminal, wrappedNT nonTerminal) 
        - handle() 
        - reset() 

    }
    class reductionImpl << (S,Aquamarine) >> {
        - reducedNT nonTerminal
        - updatingExecutionTable executionTable
        - globalUdpeRecordBeingConsidered globalUdpeRecord

        - setup(reducedNT nonTerminal, generativeNT nonTerminal, wrappedNT nonTerminal) 
        - reset() 
        - handle() 
        - avoidMemoryLeaksAtTheEndOfHandling() 
        - iterateOverAllGlobalUdpeRecordsAndExecuteMainPhases() 
        - prepareUpdatingExecutionTableToBePropagatedToReducedNT() 
        - propagateUpdatingExecutionTableToReducedNT() 
        - mergeUpdatingExecutionTableWithUnchangedExecutionTable() 
        - addNewExecutionThreadsToExecutionRecord(executionRecord executionRecord) 

    }
    interface rpe  {
    }
    interface rpeBuilder  {
    }
    class rpeBuilderImpl << (S,Aquamarine) >> {
        - state rpeBuilderState
        - currentInnerTest *rpeInnerTestImpl

        - init() 
        - addUdpeTest(udpeTest udpeTest) bool
        - addAxis(axis axis) bool
        - end() udpe

    }
    class rpeImpl << (S,Aquamarine) >> {
        - entryTest *rpeInnerTestImpl

        - entryPoint() pathPattern

        + String() string

    }
    class rpeInnerTestImpl << (S,Aquamarine) >> {
        - isEntry bool
        - behindAncestorAxis bool
        - udpeTest udpeTest
        - nextRpeInnerTest *rpeInnerTestImpl

        - matchWithReductionOf(n <font color=blue>interface</font>{}) (predicate, *rpeInnerTestImpl, bool)
        - entry() bool

        + String() string

    }
    class rpePathPathPatternImpl << (S,Aquamarine) >> {
        - currentTest *rpeInnerTestImpl

        - isEmpty() bool
        - matchWithReductionOf(n <font color=blue>interface</font>{}, doUpdate bool) (predicate, pathPattern, bool)

        + String() string

    }
    class rule << (S,Aquamarine) >> {
        - lhs uint16
        - rhs []uint16

    }
    interface speculation  {
        - evaluate(v evaluator) customBool

    }
    class speculationImpl << (S,Aquamarine) >> {
        - evaluationsCount int
        - prd predicate
        - ctx nonTerminal
        - el *list.Element

        - evaluate(v evaluator) customBool

        + String() string

    }
    interface speculationList  {
        - addSpeculation(prd predicate, ctx nonTerminal) speculation
        - removeSpeculation(sp speculation) bool
        - newIterator() speculationListIterator
        - iterate(callback speculationListIterableCallback) 
        - len() int

    }
    class speculationListImpl << (S,Aquamarine) >> {
        - list *list.List

        - addSpeculation(prd predicate, ctx nonTerminal) speculation
        - removeSpeculation(sp speculation) bool
        - len() int
        - newIterator() speculationListIterator
        - iterate(callback speculationListIterableCallback) 

    }
    interface speculationListIterator  {
        - next() (speculation, bool)
        - hasNext() bool

    }
    class speculationListIteratorImpl << (S,Aquamarine) >> {
        - nextEl *list.Element

        - next() (speculation, bool)
        - hasNext() bool

    }
    class stack << (S,Aquamarine) >> {
        + Data []symbol
        + Tos int
        + Prev *stack
        + Next *stack

    }
    class stackPool << (S,Aquamarine) >> {
        - pool []stack
        - cur int

        + Get() *stack
        + Remainder() int

    }
    class stackPtr << (S,Aquamarine) >> {
        + Data []*symbol
        + Tos int
        + Prev *stackPtr
        + Next *stackPtr

    }
    class stackPtrPool << (S,Aquamarine) >> {
        - pool []stackPtr
        - cur int

        + Get() *stackPtr
        + Remainder() int

    }
    class symbol << (S,Aquamarine) >> {
        + Token uint16
        + Precedence uint16
        + Value <font color=blue>interface</font>{}
        + Next *symbol
        + Child *symbol

        - printTreeR(level int) 

        + PrintTreeln() 

    }
    class text << (S,Aquamarine) >> {
        - data string
        - posInDocument *position

        - setFromText(tsv textSemanticValue) 
        - position() *position

        + String() string

    }
    class textSemanticValue << (S,Aquamarine) >> {
        - data string
        - posInDocument *position

    }
    class textTest << (S,Aquamarine) >> {
        - data string

        - predicate() predicate
        - test(node <font color=blue>interface</font>{}) bool

        + String() string

    }
    interface udpe  {
        - entryPoint() pathPattern

        + String() string

    }
    interface udpeBuilder  {
        - init() 
        - addUdpeTest(udpeTest udpeTest) bool
        - addAxis(axis axis) bool
        - end() udpe

    }
    interface udpeTest  {
        - test(tested <font color=blue>interface</font>{}) bool
        - predicate() predicate

    }
    class udpeType << (S,Aquamarine) >> {
        + String() string

    }
    class xpath.atomID << (T, #FF7700) >>  {
    }
    class xpath.axis << (T, #FF7700) >>  {
    }
    class xpath.customBool << (T, #FF7700) >>  {
    }
    class xpath.evaluator << (T, #FF7700) >>  {
    }
    class xpath.executionTableIterableCallback << (T, #FF7700) >>  {
    }
    class xpath.executionThreadListIterableCallback << (T, #FF7700) >>  {
    }
    class xpath.fpeBuilderState << (T, #FF7700) >>  {
    }
    class xpath.fpeStringificationMode << (T, #FF7700) >>  {
    }
    class xpath.globalTableIterableCallback << (T, #FF7700) >>  {
    }
    class xpath.implementedMapType << (T, #FF7700) >>  {
    }
    class xpath.lexerDfa << (T, #FF7700) >>  {
    }
    class xpath.mainQueryType << (T, #FF7700) >>  {
    }
    class xpath.opConstructor << (T, #FF7700) >>  {
    }
    class xpath.rpeBuilderState << (T, #FF7700) >>  {
    }
    class xpath.rpeStringificationMode << (T, #FF7700) >>  {
    }
    class xpath.speculationListIterableCallback << (T, #FF7700) >>  {
    }
    class xpath.udpeType << (T, #FF7700) >>  {
    }
}
"xpath.udpe" *-- "xpath.fpe"
"xpath.udpeBuilder" *-- "xpath.fpeBuilder"
"xpath.openTagSemanticValue" *-- "xpath.openCloseTagSemanticValue"
"xpath.udpe" *-- "xpath.rpe"
"xpath.udpeBuilder" *-- "xpath.rpeBuilder"

"xpath.operator" <|-- "xpath.andOperatorImpl"
"xpath.operator" <|-- "xpath.atomOperatorImpl"
"xpath.contextSolutionsMap" <|-- "xpath.contextSolutionsMapImpl"
"xpath.node" <|-- "xpath.element"
"xpath.udpeTest" <|-- "xpath.elementTest"
"xpath.executionRecord" <|-- "xpath.executionRecordImpl"
"xpath.executionTable" <|-- "xpath.executionTableImpl"
"xpath.executionThread" <|-- "xpath.executionThreadImpl"
"xpath.executionThreadList" <|-- "xpath.executionThreadListImpl"
"xpath.executionThreadListIterator" <|-- "xpath.executionThreadListIteratorImpl"
"xpath.ExecutorCommand" <|-- "xpath.executorCommandImpl"
"xpath.executor" <|-- "xpath.executorImpl"
"xpath.udpeBuilder" <|-- "xpath.fpeBuilderImpl"
"xpath.udpe" <|-- "xpath.fpeImpl"
"xpath.pathPattern" <|-- "xpath.fpePathPatternImpl"
"xpath.globalNudpeRecord" <|-- "xpath.globalNudpeRecordImpl"
"xpath.globalNudpeTable" <|-- "xpath.globalNudpeTableImpl"
"xpath.globalNudpeTableIterator" <|-- "xpath.globalNudpeTableIteratorImpl"
"xpath.globalUdpeRecord" <|-- "xpath.globalUdpeRecordImpl"
"xpath.globalUdpeTable" <|-- "xpath.globalUdpeTableImpl"
"xpath.nonTerminal" <|-- "xpath.nonTerminalImpl"
"xpath.Logger" <|-- "xpath.nopLoggerImpl"
"xpath.operator" <|-- "xpath.notOperatorImpl"
"xpath.operator" <|-- "xpath.orOperatorImpl"
"xpath.Position" <|-- "xpath.position"
"xpath.predicate" <|-- "xpath.predicateImpl"
"xpath.reduction" <|-- "xpath.reductionImpl"
"xpath.udpeBuilder" <|-- "xpath.rpeBuilderImpl"
"xpath.udpe" <|-- "xpath.rpeImpl"
"xpath.pathPattern" <|-- "xpath.rpePathPathPatternImpl"
"xpath.speculation" <|-- "xpath.speculationImpl"
"xpath.speculationList" <|-- "xpath.speculationListImpl"
"xpath.speculationListIterator" <|-- "xpath.speculationListIteratorImpl"
"xpath.node" <|-- "xpath.text"
"xpath.udpeTest" <|-- "xpath.textTest"

"__builtin__.int" #.. "xpath.atomID"
"__builtin__.int" #.. "xpath.axis"
"__builtin__.int" #.. "xpath.customBool"
"__builtin__.int" #.. "xpath.fpeBuilderState"
"__builtin__.int" #.. "xpath.fpeStringificationMode"
"__builtin__.int" #.. "xpath.mainQueryType"
"__builtin__.int" #.. "xpath.rpeBuilderState"
"__builtin__.int" #.. "xpath.rpeStringificationMode"
"__builtin__.int" #.. "xpath.udpeType"
"xpath.<font color=blue>func</font>() operator" #.. "xpath.opConstructor"
"xpath.<font color=blue>func</font>(executionThread) bool" #.. "xpath.executionThreadListIterableCallback"
"xpath.<font color=blue>func</font>(int, executionRecord) bool" #.. "xpath.executionTableIterableCallback"
"xpath.<font color=blue>func</font>(int, globalUdpeRecord) " #.. "xpath.globalTableIterableCallback"
"xpath.<font color=blue>func</font>(int, nonTerminal, int) customBool" #.. "xpath.evaluator"
"xpath.<font color=blue>func</font>(speculation) bool" #.. "xpath.speculationListIterableCallback"
"xpath.<font color=blue>map</font>[nonTerminal][]{packageName}nonTerminal" #.. "xpath.implementedMapType"
"xpath.[]lexerDfaState" #.. "xpath.lexerDfa"
@enduml
